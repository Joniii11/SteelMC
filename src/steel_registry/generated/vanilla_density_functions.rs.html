<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `steel-registry/src/generated/vanilla_density_functions.rs`."><title>vanilla_density_functions.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="steel_registry" data-themes="" data-resource-suffix="" data-rustdoc-version="1.96.0-nightly (38c0de8dc 2026-02-28)" data-channel="nightly" data-search-js="search-63369b7b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../../static.files/storage-41dd4d93.js"></script><script defer src="../../../static.files/src-script-813739b1.js"></script><script defer src="../../../src-files.js"></script><script defer src="../../../static.files/main-5013f961.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><h1><div class="sub-heading">steel_registry/generated/</div>vanilla_density_functions.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-1"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="kw">use </span>steel_utils :: density :: spline_eval ; <span class="kw">use </span>steel_utils :: density :: RarityValueMapper ; <span class="kw">use </span>steel_utils :: math :: { clamp , map_clamped } ; <span class="kw">use </span>steel_utils :: noise :: NormalNoise ; <span class="kw">use </span>steel_utils :: random :: RandomSplitter ; # [doc = <span class="string">r" All noise generators needed by this dimension's density functions."</span>] # [doc = <span class="string">r""</span>] # [doc = <span class="string">r" Created at runtime from a seed via the `create` method."</span>] <span class="kw">pub struct </span>OverworldNoises { <span class="kw">pub </span>n_aquifer_barrier : NormalNoise , <span class="kw">pub </span>n_aquifer_fluid_level_floodedness : NormalNoise , <span class="kw">pub </span>n_aquifer_fluid_level_spread : NormalNoise , <span class="kw">pub </span>n_aquifer_lava : NormalNoise , <span class="kw">pub </span>n_cave_cheese : NormalNoise , <span class="kw">pub </span>n_cave_entrance : NormalNoise , <span class="kw">pub </span>n_cave_layer : NormalNoise , <span class="kw">pub </span>n_continentalness : NormalNoise , <span class="kw">pub </span>n_erosion : NormalNoise , <span class="kw">pub </span>n_jagged : NormalNoise , <span class="kw">pub </span>n_noodle : NormalNoise , <span class="kw">pub </span>n_noodle_ridge_a : NormalNoise , <span class="kw">pub </span>n_noodle_ridge_b : NormalNoise , <span class="kw">pub </span>n_noodle_thickness : NormalNoise , <span class="kw">pub </span>n_offset : NormalNoise , <span class="kw">pub </span>n_ore_gap : NormalNoise , <span class="kw">pub </span>n_ore_vein_a : NormalNoise , <span class="kw">pub </span>n_ore_vein_b : NormalNoise , <span class="kw">pub </span>n_ore_veininess : NormalNoise , <span class="kw">pub </span>n_pillar : NormalNoise , <span class="kw">pub </span>n_pillar_rareness : NormalNoise , <span class="kw">pub </span>n_pillar_thickness : NormalNoise , <span class="kw">pub </span>n_ridge : NormalNoise , <span class="kw">pub </span>n_spaghetti_2d : NormalNoise , <span class="kw">pub </span>n_spaghetti_2d_elevation : NormalNoise , <span class="kw">pub </span>n_spaghetti_2d_modulator : NormalNoise , <span class="kw">pub </span>n_spaghetti_2d_thickness : NormalNoise , <span class="kw">pub </span>n_spaghetti_3d_1 : NormalNoise , <span class="kw">pub </span>n_spaghetti_3d_2 : NormalNoise , <span class="kw">pub </span>n_spaghetti_3d_rarity : NormalNoise , <span class="kw">pub </span>n_spaghetti_3d_thickness : NormalNoise , <span class="kw">pub </span>n_spaghetti_roughness : NormalNoise , <span class="kw">pub </span>n_spaghetti_roughness_modulator : NormalNoise , <span class="kw">pub </span>n_temperature : NormalNoise , <span class="kw">pub </span>n_vegetation : NormalNoise } <span class="kw">impl </span>OverworldNoises { # [doc = <span class="string">r" Create all noise generators from a seed's positional splitter and noise parameters."</span>] <span class="kw">pub fn </span>create (splitter : &amp; RandomSplitter , params : &amp; rustc_hash :: FxHashMap &lt; String , steel_utils :: density :: NoiseParameters &gt; ,) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ n_aquifer_barrier : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:aquifer_barrier"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:aquifer_barrier"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:aquifer_barrier" </span>, p . first_octave , &amp; p . amplitudes) } , n_aquifer_fluid_level_floodedness : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:aquifer_fluid_level_floodedness"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:aquifer_fluid_level_floodedness"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:aquifer_fluid_level_floodedness" </span>, p . first_octave , &amp; p . amplitudes) } , n_aquifer_fluid_level_spread : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:aquifer_fluid_level_spread"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:aquifer_fluid_level_spread"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:aquifer_fluid_level_spread" </span>, p . first_octave , &amp; p . amplitudes) } , n_aquifer_lava : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:aquifer_lava"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:aquifer_lava"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:aquifer_lava" </span>, p . first_octave , &amp; p . amplitudes) } , n_cave_cheese : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:cave_cheese"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:cave_cheese"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:cave_cheese" </span>, p . first_octave , &amp; p . amplitudes) } , n_cave_entrance : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:cave_entrance"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:cave_entrance"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:cave_entrance" </span>, p . first_octave , &amp; p . amplitudes) } , n_cave_layer : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:cave_layer"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:cave_layer"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:cave_layer" </span>, p . first_octave , &amp; p . amplitudes) } , n_continentalness : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:continentalness"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:continentalness"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:continentalness" </span>, p . first_octave , &amp; p . amplitudes) } , n_erosion : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:erosion"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:erosion"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:erosion" </span>, p . first_octave , &amp; p . amplitudes) } , n_jagged : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:jagged"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:jagged"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:jagged" </span>, p . first_octave , &amp; p . amplitudes) } , n_noodle : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:noodle"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:noodle"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:noodle" </span>, p . first_octave , &amp; p . amplitudes) } , n_noodle_ridge_a : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:noodle_ridge_a"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:noodle_ridge_a"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:noodle_ridge_a" </span>, p . first_octave , &amp; p . amplitudes) } , n_noodle_ridge_b : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:noodle_ridge_b"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:noodle_ridge_b"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:noodle_ridge_b" </span>, p . first_octave , &amp; p . amplitudes) } , n_noodle_thickness : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:noodle_thickness"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:noodle_thickness"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:noodle_thickness" </span>, p . first_octave , &amp; p . amplitudes) } , n_offset : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:offset"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:offset"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:offset" </span>, p . first_octave , &amp; p . amplitudes) } , n_ore_gap : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:ore_gap"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:ore_gap"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:ore_gap" </span>, p . first_octave , &amp; p . amplitudes) } , n_ore_vein_a : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:ore_vein_a"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:ore_vein_a"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:ore_vein_a" </span>, p . first_octave , &amp; p . amplitudes) } , n_ore_vein_b : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:ore_vein_b"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:ore_vein_b"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:ore_vein_b" </span>, p . first_octave , &amp; p . amplitudes) } , n_ore_veininess : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:ore_veininess"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:ore_veininess"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:ore_veininess" </span>, p . first_octave , &amp; p . amplitudes) } , n_pillar : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:pillar"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:pillar"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:pillar" </span>, p . first_octave , &amp; p . amplitudes) } , n_pillar_rareness : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:pillar_rareness"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:pillar_rareness"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:pillar_rareness" </span>, p . first_octave , &amp; p . amplitudes) } , n_pillar_thickness : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:pillar_thickness"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:pillar_thickness"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:pillar_thickness" </span>, p . first_octave , &amp; p . amplitudes) } , n_ridge : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:ridge"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:ridge"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:ridge" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_2d : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_2d"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_2d"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_2d" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_2d_elevation : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_2d_elevation"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_2d_elevation"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_2d_elevation" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_2d_modulator : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_2d_modulator"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_2d_modulator"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_2d_modulator" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_2d_thickness : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_2d_thickness"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_2d_thickness"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_2d_thickness" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_3d_1 : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_3d_1"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_3d_1"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_3d_1" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_3d_2 : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_3d_2"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_3d_2"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_3d_2" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_3d_rarity : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_3d_rarity"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_3d_rarity"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_3d_rarity" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_3d_thickness : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_3d_thickness"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_3d_thickness"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_3d_thickness" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_roughness : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_roughness"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_roughness"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_roughness" </span>, p . first_octave , &amp; p . amplitudes) } , n_spaghetti_roughness_modulator : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:spaghetti_roughness_modulator"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:spaghetti_roughness_modulator"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:spaghetti_roughness_modulator" </span>, p . first_octave , &amp; p . amplitudes) } , n_temperature : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:temperature"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:temperature"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:temperature" </span>, p . first_octave , &amp; p . amplitudes) } , n_vegetation : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:vegetation"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:vegetation"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:vegetation" </span>, p . first_octave , &amp; p . amplitudes) } } } } # [doc = <span class="string">r" Column-level cache for flat-cached (xz-only) density function results."</span>] # [doc = <span class="string">r""</span>] # [doc = <span class="string">r" Call [`ensure`](Self::ensure) before reading values. Values are recomputed"</span>] # [doc = <span class="string">r" only when `(x, z)` changes."</span>] <span class="kw">pub struct </span>OverworldColumnCache { # [doc = <span class="string">r" Cached x block coordinate."</span>] <span class="kw">pub </span>x : i32 , # [doc = <span class="string">r" Cached z block coordinate."</span>] <span class="kw">pub </span>z : i32 , valid : bool , <span class="kw">pub </span>df_shift_x : f64 , <span class="kw">pub </span>df_shift_z : f64 , <span class="kw">pub </span>df_overworld__continents : f64 , <span class="kw">pub </span>df_overworld__erosion : f64 , <span class="kw">pub </span>df_overworld__ridges : f64 , <span class="kw">pub </span>df_overworld__ridges_folded : f64 , <span class="kw">pub </span>df_overworld__offset : f64 , <span class="kw">pub </span>df_overworld__factor : f64 , <span class="kw">pub </span>df_overworld__jaggedness : f64 , <span class="kw">pub </span>router_continentalness : f64 , <span class="kw">pub </span>router_erosion : f64 , <span class="kw">pub </span>router_preliminary_surface_level : f64 , <span class="kw">pub </span>router_ridges : f64 , <span class="kw">pub </span>router_temperature : f64 , <span class="kw">pub </span>router_vegetation : f64 } <span class="kw">impl </span>OverworldColumnCache { # [doc = <span class="string">r" Create a new, empty column cache."</span>] # [must_use] <span class="kw">pub fn </span>new () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ x : <span class="number">0 </span>, z : <span class="number">0 </span>, valid : <span class="bool-val">false </span>, df_shift_x : <span class="number">0.0 </span>, df_shift_z : <span class="number">0.0 </span>, df_overworld__continents : <span class="number">0.0 </span>, df_overworld__erosion : <span class="number">0.0 </span>, df_overworld__ridges : <span class="number">0.0 </span>, df_overworld__ridges_folded : <span class="number">0.0 </span>, df_overworld__offset : <span class="number">0.0 </span>, df_overworld__factor : <span class="number">0.0 </span>, df_overworld__jaggedness : <span class="number">0.0 </span>, router_continentalness : <span class="number">0.0 </span>, router_erosion : <span class="number">0.0 </span>, router_preliminary_surface_level : <span class="number">0.0 </span>, router_ridges : <span class="number">0.0 </span>, router_temperature : <span class="number">0.0 </span>, router_vegetation : <span class="number">0.0 </span>} } # [doc = <span class="string">r" Ensure the cache is populated for the given `(x, z)` block coordinates."</span>] # [doc = <span class="string">r""</span>] # [doc = <span class="string">r" If the cache already holds values for this column, this is a no-op."</span>] # [doc = <span class="string">r" Computes all flat-cached density functions in topological order,"</span>] # [doc = <span class="string">r" then any Y-independent router entries."</span>] <span class="kw">pub fn </span>ensure (&amp; <span class="kw-2">mut </span><span class="self">self </span>, x : i32 , z : i32 , noises : &amp; OverworldNoises) { <span class="kw">if </span><span class="self">self </span>. valid &amp;&amp; <span class="self">self </span>. x == x &amp;&amp; <span class="self">self </span>. z == z { <span class="kw">return </span>; } <span class="self">self </span>. x = x ; <span class="self">self </span>. z = z ; <span class="kw">let </span>val = compute_shift_x (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_shift_x = val ; <span class="kw">let </span>val = compute_shift_z (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_shift_z = val ; <span class="kw">let </span>val = compute_overworld__continents (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_overworld__continents = val ; <span class="kw">let </span>val = compute_overworld__erosion (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_overworld__erosion = val ; <span class="kw">let </span>val = compute_overworld__ridges (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_overworld__ridges = val ; <span class="kw">let </span>val = compute_overworld__ridges_folded (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_overworld__ridges_folded = val ; <span class="kw">let </span>val = compute_overworld__offset (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_overworld__offset = val ; <span class="kw">let </span>val = compute_overworld__factor (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_overworld__factor = val ; <span class="kw">let </span>val = compute_overworld__jaggedness (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_overworld__jaggedness = val ; <span class="kw">let </span>val = compute_router_continentalness (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_continentalness = val ; <span class="kw">let </span>val = compute_router_erosion (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_erosion = val ; <span class="kw">let </span>val = compute_router_preliminary_surface_level (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_preliminary_surface_level = val ; <span class="kw">let </span>val = compute_router_ridges (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_ridges = val ; <span class="kw">let </span>val = compute_router_temperature (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_temperature = val ; <span class="kw">let </span>val = compute_router_vegetation (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_vegetation = val ; <span class="self">self </span>. valid = <span class="bool-val">true </span>; } } # [doc = <span class="string">"`minecraft:overworld/base_3d_noise`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__base_3d_noise (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { noises . n_offset . get_value (f64 :: from (x) * <span class="number">0.003125 </span>, f64 :: from (y) * <span class="number">0.00078125 </span>, f64 :: from (z) * <span class="number">0.003125</span>) * <span class="number">8.0 </span>} # [doc = <span class="string">"`minecraft:overworld/caves/spaghetti_roughness_function`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__caves__spaghetti_roughness_function (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { ((((- <span class="number">0.05</span>) + (((- <span class="number">0.05</span>) * (noises . n_spaghetti_roughness_modulator . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>)))))) * (((- <span class="number">0.4</span>) + ((noises . n_spaghetti_roughness . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>)) . abs ())))) } # [doc = <span class="string">"`minecraft:overworld/caves/entrances`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__caves__entrances (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { f64 :: min (((((<span class="number">0.37</span>) + (noises . n_cave_entrance . get_value (f64 :: from (x) * <span class="number">0.75 </span>, f64 :: from (y) * <span class="number">0.5 </span>, f64 :: from (z) * <span class="number">0.75</span>)))) + (map_clamped (f64 :: from (y) , - <span class="number">10.0 </span>, <span class="number">30.0 </span>, <span class="number">0.3 </span>, <span class="number">0.0</span>))) , ((compute_overworld__caves__spaghetti_roughness_function (noises , cache , x , y , z)) + (clamp (((f64 :: max ({ <span class="kw">let </span>rarity = noises . n_spaghetti_3d_rarity . get_value (f64 :: from (x) * <span class="number">2.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">2.0</span>) ; <span class="kw">let </span>scale = RarityValueMapper :: Tunnels . get_values (rarity) ; scale * noises . n_spaghetti_3d_1 . get_value (f64 :: from (x) / scale , f64 :: from (y) / scale , f64 :: from (z) / scale ,) . abs () } , { <span class="kw">let </span>rarity = noises . n_spaghetti_3d_rarity . get_value (f64 :: from (x) * <span class="number">2.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">2.0</span>) ; <span class="kw">let </span>scale = RarityValueMapper :: Tunnels . get_values (rarity) ; scale * noises . n_spaghetti_3d_2 . get_value (f64 :: from (x) / scale , f64 :: from (y) / scale , f64 :: from (z) / scale ,) . abs () })) + (((- <span class="number">0.0765</span>) + (((- <span class="number">0.011499999999999996</span>) * (noises . n_spaghetti_3d_thickness . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>))))))) , - <span class="number">1.0 </span>, <span class="number">1.0</span>)))) } # [doc = <span class="string">"`minecraft:y`"</span>] # [inline] <span class="kw">fn </span>compute_y (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { map_clamped (f64 :: from (y) , - <span class="number">4064.0 </span>, <span class="number">4062.0 </span>, - <span class="number">4064.0 </span>, <span class="number">4062.0</span>) } # [doc = <span class="string">"`minecraft:overworld/caves/noodle`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__caves__noodle (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { { <span class="kw">let </span>v = { <span class="kw">let </span>v = compute_y (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">60.0 </span>&amp;&amp; v &lt; <span class="number">321.0 </span>{ noises . n_noodle . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>) } <span class="kw">else </span>{ - <span class="number">1.0 </span>} } ; <span class="kw">if </span>v &gt;= - <span class="number">1000000.0 </span>&amp;&amp; v &lt; <span class="number">0.0 </span>{ <span class="number">64.0 </span>} <span class="kw">else </span>{ (({ <span class="kw">let </span>v = compute_y (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">60.0 </span>&amp;&amp; v &lt; <span class="number">321.0 </span>{ ((- <span class="number">0.07500000000000001</span>) + (((- <span class="number">0.025</span>) * (noises . n_noodle_thickness . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>))))) } <span class="kw">else </span>{ <span class="number">0.0 </span>} }) + (((<span class="number">1.5</span>) * (f64 :: max (({ <span class="kw">let </span>v = compute_y (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">60.0 </span>&amp;&amp; v &lt; <span class="number">321.0 </span>{ noises . n_noodle_ridge_a . get_value (f64 :: from (x) * <span class="number">2.6666666666666665 </span>, f64 :: from (y) * <span class="number">2.6666666666666665 </span>, f64 :: from (z) * <span class="number">2.6666666666666665</span>) } <span class="kw">else </span>{ <span class="number">0.0 </span>} }) . abs () , ({ <span class="kw">let </span>v = compute_y (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">60.0 </span>&amp;&amp; v &lt; <span class="number">321.0 </span>{ noises . n_noodle_ridge_b . get_value (f64 :: from (x) * <span class="number">2.6666666666666665 </span>, f64 :: from (y) * <span class="number">2.6666666666666665 </span>, f64 :: from (z) * <span class="number">2.6666666666666665</span>) } <span class="kw">else </span>{ <span class="number">0.0 </span>} }) . abs ()))))) } } } # [doc = <span class="string">"`minecraft:overworld/caves/pillars`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__caves__pillars (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { ((((((<span class="number">2.0</span>) * (noises . n_pillar . get_value (f64 :: from (x) * <span class="number">25.0 </span>, f64 :: from (y) * <span class="number">0.3 </span>, f64 :: from (z) * <span class="number">25.0</span>)))) + (((- <span class="number">1.0</span>) + (((- <span class="number">1.0</span>) * (noises . n_pillar_rareness . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>)))))))) * ({ <span class="kw">let </span>v = ((<span class="number">0.55</span>) + (((<span class="number">0.55</span>) * (noises . n_pillar_thickness . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>))))) ; v * v * v })) } # [doc = <span class="string">"`minecraft:overworld/caves/spaghetti_2d_thickness_modulator`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__caves__spaghetti_2d_thickness_modulator (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { ((- <span class="number">0.95</span>) + (((- <span class="number">0.35000000000000003</span>) * (noises . n_spaghetti_2d_thickness . get_value (f64 :: from (x) * <span class="number">2.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">2.0</span>))))) } # [doc = <span class="string">"`minecraft:overworld/caves/spaghetti_2d`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__caves__spaghetti_2d (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { clamp (f64 :: max ((({ <span class="kw">let </span>rarity = noises . n_spaghetti_2d_modulator . get_value (f64 :: from (x) * <span class="number">2.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">2.0</span>) ; <span class="kw">let </span>scale = RarityValueMapper :: Caves . get_values (rarity) ; scale * noises . n_spaghetti_2d . get_value (f64 :: from (x) / scale , f64 :: from (y) / scale , f64 :: from (z) / scale ,) . abs () }) + (((<span class="number">0.083</span>) * (compute_overworld__caves__spaghetti_2d_thickness_modulator (noises , cache , x , y , z))))) , { <span class="kw">let </span>v = (((((((<span class="number">0.0</span>) + (((<span class="number">8.0</span>) * (noises . n_spaghetti_2d_elevation . get_value (f64 :: from (x) * <span class="number">1.0 </span>, <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">1.0</span>)))))) + (map_clamped (f64 :: from (y) , - <span class="number">64.0 </span>, <span class="number">320.0 </span>, <span class="number">8.0 </span>, - <span class="number">40.0</span>)))) . abs ()) + (compute_overworld__caves__spaghetti_2d_thickness_modulator (noises , cache , x , y , z))) ; v * v * v }) , - <span class="number">1.0 </span>, <span class="number">1.0</span>) } # [doc = <span class="string">"`minecraft:shift_x`"</span>] # [inline] <span class="kw">fn </span>compute_shift_x (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { noises . n_offset . get_value (f64 :: from (x) * <span class="number">0.25 </span>, <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25</span>) * <span class="number">4.0 </span>} # [doc = <span class="string">"`minecraft:shift_z`"</span>] # [inline] <span class="kw">fn </span>compute_shift_z (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { noises . n_offset . get_value (f64 :: from (z) * <span class="number">0.25 </span>, f64 :: from (x) * <span class="number">0.25 </span>, <span class="number">0.0</span>) * <span class="number">4.0 </span>} # [doc = <span class="string">"`minecraft:overworld/continents`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__continents (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { { <span class="kw">let </span>dx = cache . df_shift_x ; <span class="kw">let </span>dz = cache . df_shift_z ; noises . n_continentalness . get_value (f64 :: from (x) * <span class="number">0.25 </span>+ dx , <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25 </span>+ dz ,) } } # [doc = <span class="string">"`minecraft:overworld/erosion`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__erosion (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { { <span class="kw">let </span>dx = cache . df_shift_x ; <span class="kw">let </span>dz = cache . df_shift_z ; noises . n_erosion . get_value (f64 :: from (x) * <span class="number">0.25 </span>+ dx , <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25 </span>+ dz ,) } } # [doc = <span class="string">"`minecraft:overworld/ridges`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__ridges (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { { <span class="kw">let </span>dx = cache . df_shift_x ; <span class="kw">let </span>dz = cache . df_shift_z ; noises . n_ridge . get_value (f64 :: from (x) * <span class="number">0.25 </span>+ dx , <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25 </span>+ dz ,) } } # [doc = <span class="string">"`minecraft:overworld/ridges_folded`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__ridges_folded (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { ((- <span class="number">3.0</span>) * (((- <span class="number">0.3333333333333333</span>) + ((((- <span class="number">0.6666666666666666</span>) + ((cache . df_overworld__ridges) . abs ()))) . abs ())))) } # [doc = <span class="string">"`minecraft:overworld/offset`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__offset (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { ((((<span class="number">0.0</span>) * (((<span class="number">1.0</span>) + (((- <span class="number">1.0</span>) * (<span class="number">1.0</span>))))))) + (((((- <span class="number">0.5037500262260437</span>) + ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">10</span>] = [- <span class="number">1.1 </span>, - <span class="number">1.02 </span>, - <span class="number">0.51 </span>, - <span class="number">0.44 </span>, - <span class="number">0.18 </span>, - <span class="number">0.16 </span>, - <span class="number">0.15 </span>, - <span class="number">0.1 </span>, <span class="number">0.25 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">10</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__continents) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.044 </span>, <span class="number">1 </span>=&gt; - <span class="number">0.2222 </span>, <span class="number">2 </span>=&gt; - <span class="number">0.2222 </span>, <span class="number">3 </span>=&gt; - <span class="number">0.12 </span>, <span class="number">4 </span>=&gt; - <span class="number">0.12 </span>, <span class="number">5 </span>=&gt; spline_helper_0 (noises , cache , x , z) , <span class="number">6 </span>=&gt; spline_helper_8 (noises , cache , x , z) , <span class="number">7 </span>=&gt; spline_helper_16 (noises , cache , x , z) , <span class="number">8 </span>=&gt; spline_helper_24 (noises , cache , x , z) , <span class="number">9 </span>=&gt; spline_helper_38 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }))) * (<span class="number">1.0</span>)))) } # [doc = <span class="string">"`minecraft:overworld/depth`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__depth (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { ((map_clamped (f64 :: from (y) , - <span class="number">64.0 </span>, <span class="number">320.0 </span>, <span class="number">1.5 </span>, - <span class="number">1.5</span>)) + (cache . df_overworld__offset)) } # [doc = <span class="string">"`minecraft:overworld/factor`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__factor (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { ((<span class="number">10.0</span>) + (((<span class="number">1.0</span>) * (((- <span class="number">10.0</span>) + ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">0.19 </span>, - <span class="number">0.15 </span>, - <span class="number">0.1 </span>, <span class="number">0.03 </span>, <span class="number">0.06</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__continents) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">3.95 </span>, <span class="number">1 </span>=&gt; spline_helper_52 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_63 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_74 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_85 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) })))))) } # [doc = <span class="string">"`minecraft:overworld/jaggedness`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__jaggedness (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { ((<span class="number">0.0</span>) + (((<span class="number">1.0</span>) * (((- <span class="number">0.0</span>) + ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">0.11 </span>, <span class="number">0.03 </span>, <span class="number">0.65</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__continents) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.0 </span>, <span class="number">1 </span>=&gt; spline_helper_100 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_107 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) })))))) } # [doc = <span class="string">"`minecraft:overworld/sloped_cheese`"</span>] # [inline] <span class="kw">fn </span>compute_overworld__sloped_cheese (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { ((((<span class="number">4.0</span>) * ({ <span class="kw">let </span>v = ((((compute_overworld__depth (noises , cache , x , y , z)) + (((cache . df_overworld__jaggedness) * ({ <span class="kw">let </span>v = noises . n_jagged . get_value (f64 :: from (x) * <span class="number">1500.0 </span>, <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">1500.0</span>) ; <span class="kw">if </span>v &gt; <span class="number">0.0 </span>{ v } <span class="kw">else </span>{ v * <span class="number">0.5 </span>} }))))) * (cache . df_overworld__factor)) ; <span class="kw">if </span>v &gt; <span class="number">0.0 </span>{ v } <span class="kw">else </span>{ v * <span class="number">0.25 </span>} }))) + (compute_overworld__base_3d_noise (noises , cache , x , y , z))) } # [inline] <span class="kw">fn </span>spline_helper_1 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">1.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.38940096 </span>, <span class="number">0.38940096</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.08880186 </span>, <span class="number">1 </span>=&gt; <span class="number">0.69000006 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_2 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">1.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.37788022 </span>, <span class="number">0.37788022</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.115760356 </span>, <span class="number">1 </span>=&gt; <span class="number">0.6400001 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_3 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">6</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.75 </span>, - <span class="number">0.65 </span>, <span class="number">0.5954547 </span>, <span class="number">0.6054547 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">6</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.2534563 </span>, <span class="number">0.2534563</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.2222 </span>, <span class="number">1 </span>=&gt; - <span class="number">0.2222 </span>, <span class="number">2 </span>=&gt; <span class="number">0.0 </span>, <span class="number">3 </span>=&gt; <span class="number">0.000000029802322 </span>, <span class="number">4 </span>=&gt; <span class="number">0.000000029802322 </span>, <span class="number">5 </span>=&gt; <span class="number">0.100000024 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_4 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.007000001</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.3 </span>, <span class="number">1 </span>=&gt; <span class="number">0.05 </span>, <span class="number">2 </span>=&gt; <span class="number">0.05 </span>, <span class="number">3 </span>=&gt; <span class="number">0.05 </span>, <span class="number">4 </span>=&gt; <span class="number">0.060000002 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_5 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.1 </span>, <span class="number">0.007000001</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.15 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; <span class="number">0.0 </span>, <span class="number">3 </span>=&gt; <span class="number">0.05 </span>, <span class="number">4 </span>=&gt; <span class="number">0.060000002 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_6 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.15 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; <span class="number">0.0 </span>, <span class="number">3 </span>=&gt; <span class="number">0.0 </span>, <span class="number">4 </span>=&gt; <span class="number">0.0 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_7 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.06 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.02 </span>, <span class="number">1 </span>=&gt; - <span class="number">0.03 </span>, <span class="number">2 </span>=&gt; - <span class="number">0.03 </span>, <span class="number">3 </span>=&gt; <span class="number">0.0 </span>, <span class="number">4 </span>=&gt; <span class="number">0.0 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_0 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">7</span>] = [- <span class="number">0.85 </span>, - <span class="number">0.7 </span>, - <span class="number">0.4 </span>, - <span class="number">0.35 </span>, - <span class="number">0.1 </span>, <span class="number">0.2 </span>, <span class="number">0.7</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">7</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_1 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_2 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_3 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_4 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_5 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_6 (noises , cache , x , z) , <span class="number">6 </span>=&gt; spline_helper_7 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_9 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">1.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.38940096 </span>, <span class="number">0.38940096</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.08880186 </span>, <span class="number">1 </span>=&gt; <span class="number">0.69000006 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_10 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">1.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.37788022 </span>, <span class="number">0.37788022</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.115760356 </span>, <span class="number">1 </span>=&gt; <span class="number">0.6400001 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_11 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">6</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.75 </span>, - <span class="number">0.65 </span>, <span class="number">0.5954547 </span>, <span class="number">0.6054547 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">6</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.2534563 </span>, <span class="number">0.2534563</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.2222 </span>, <span class="number">1 </span>=&gt; - <span class="number">0.2222 </span>, <span class="number">2 </span>=&gt; <span class="number">0.0 </span>, <span class="number">3 </span>=&gt; <span class="number">0.000000029802322 </span>, <span class="number">4 </span>=&gt; <span class="number">0.000000029802322 </span>, <span class="number">5 </span>=&gt; <span class="number">0.100000024 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_12 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.007000001</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.3 </span>, <span class="number">1 </span>=&gt; <span class="number">0.05 </span>, <span class="number">2 </span>=&gt; <span class="number">0.05 </span>, <span class="number">3 </span>=&gt; <span class="number">0.05 </span>, <span class="number">4 </span>=&gt; <span class="number">0.060000002 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_13 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.1 </span>, <span class="number">0.007000001</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.15 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; <span class="number">0.0 </span>, <span class="number">3 </span>=&gt; <span class="number">0.05 </span>, <span class="number">4 </span>=&gt; <span class="number">0.060000002 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_14 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.15 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; <span class="number">0.0 </span>, <span class="number">3 </span>=&gt; <span class="number">0.0 </span>, <span class="number">4 </span>=&gt; <span class="number">0.0 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_15 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.06 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.02 </span>, <span class="number">1 </span>=&gt; - <span class="number">0.03 </span>, <span class="number">2 </span>=&gt; - <span class="number">0.03 </span>, <span class="number">3 </span>=&gt; <span class="number">0.0 </span>, <span class="number">4 </span>=&gt; <span class="number">0.0 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_8 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">7</span>] = [- <span class="number">0.85 </span>, - <span class="number">0.7 </span>, - <span class="number">0.4 </span>, - <span class="number">0.35 </span>, - <span class="number">0.1 </span>, <span class="number">0.2 </span>, <span class="number">0.7</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">7</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_9 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_10 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_11 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_12 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_13 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_14 (noises , cache , x , z) , <span class="number">6 </span>=&gt; spline_helper_15 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_17 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">1.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.38940096 </span>, <span class="number">0.38940096</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.08880186 </span>, <span class="number">1 </span>=&gt; <span class="number">0.69000006 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_18 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">1.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.37788022 </span>, <span class="number">0.37788022</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.115760356 </span>, <span class="number">1 </span>=&gt; <span class="number">0.6400001 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_19 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">6</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.75 </span>, - <span class="number">0.65 </span>, <span class="number">0.5954547 </span>, <span class="number">0.6054547 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">6</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.2534563 </span>, <span class="number">0.2534563</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.2222 </span>, <span class="number">1 </span>=&gt; - <span class="number">0.2222 </span>, <span class="number">2 </span>=&gt; <span class="number">0.0 </span>, <span class="number">3 </span>=&gt; <span class="number">0.000000029802322 </span>, <span class="number">4 </span>=&gt; <span class="number">0.000000029802322 </span>, <span class="number">5 </span>=&gt; <span class="number">0.100000024 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_20 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.007000001</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.25 </span>, <span class="number">1 </span>=&gt; <span class="number">0.05 </span>, <span class="number">2 </span>=&gt; <span class="number">0.05 </span>, <span class="number">3 </span>=&gt; <span class="number">0.05 </span>, <span class="number">4 </span>=&gt; <span class="number">0.060000002 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_21 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.01 </span>, <span class="number">0.01 </span>, <span class="number">0.094000004 </span>, <span class="number">0.007000001</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; <span class="number">0.001 </span>, <span class="number">2 </span>=&gt; <span class="number">0.003 </span>, <span class="number">3 </span>=&gt; <span class="number">0.05 </span>, <span class="number">4 </span>=&gt; <span class="number">0.060000002 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_22 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_23 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.12 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.02 </span>, <span class="number">1 </span>=&gt; - <span class="number">0.03 </span>, <span class="number">2 </span>=&gt; - <span class="number">0.03 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_16 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">7</span>] = [- <span class="number">0.85 </span>, - <span class="number">0.7 </span>, - <span class="number">0.4 </span>, - <span class="number">0.35 </span>, - <span class="number">0.1 </span>, <span class="number">0.2 </span>, <span class="number">0.7</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">7</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_17 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_18 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_19 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_20 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_21 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_22 (noises , cache , x , z) , <span class="number">6 </span>=&gt; spline_helper_23 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_25 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, <span class="number">0.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.5138249 </span>, <span class="number">0.5138249</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.20235021 </span>, <span class="number">1 </span>=&gt; <span class="number">0.7161751 </span>, <span class="number">2 </span>=&gt; <span class="number">1.23 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_26 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, <span class="number">0.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.43317974 </span>, <span class="number">0.43317974</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.2 </span>, <span class="number">1 </span>=&gt; <span class="number">0.44682026 </span>, <span class="number">2 </span>=&gt; <span class="number">0.88 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_27 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, <span class="number">0.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.3917051 </span>, <span class="number">0.3917051</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.2 </span>, <span class="number">1 </span>=&gt; <span class="number">0.30829495 </span>, <span class="number">2 </span>=&gt; <span class="number">0.70000005 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_28 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.049000014</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.25 </span>, <span class="number">1 </span>=&gt; <span class="number">0.35 </span>, <span class="number">2 </span>=&gt; <span class="number">0.35 </span>, <span class="number">3 </span>=&gt; <span class="number">0.35 </span>, <span class="number">4 </span>=&gt; <span class="number">0.42000002 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_29 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.07 </span>, <span class="number">0.07 </span>, <span class="number">0.658 </span>, <span class="number">0.049000014</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0069999998 </span>, <span class="number">2 </span>=&gt; <span class="number">0.021 </span>, <span class="number">3 </span>=&gt; <span class="number">0.35 </span>, <span class="number">4 </span>=&gt; <span class="number">0.42000002 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_30 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_31 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_33 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_32 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; spline_helper_33 (noises , cache , x , z) , <span class="number">2 </span>=&gt; <span class="number">0.17 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_35 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_34 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; spline_helper_35 (noises , cache , x , z) , <span class="number">2 </span>=&gt; <span class="number">0.17 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_36 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.1 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_37 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.12 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.02 </span>, <span class="number">1 </span>=&gt; - <span class="number">0.03 </span>, <span class="number">2 </span>=&gt; - <span class="number">0.03 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_24 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">11</span>] = [- <span class="number">0.85 </span>, - <span class="number">0.7 </span>, - <span class="number">0.4 </span>, - <span class="number">0.35 </span>, - <span class="number">0.1 </span>, <span class="number">0.2 </span>, <span class="number">0.4 </span>, <span class="number">0.45 </span>, <span class="number">0.55 </span>, <span class="number">0.58 </span>, <span class="number">0.7</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">11</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_25 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_26 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_27 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_28 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_29 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_30 (noises , cache , x , z) , <span class="number">6 </span>=&gt; spline_helper_31 (noises , cache , x , z) , <span class="number">7 </span>=&gt; spline_helper_32 (noises , cache , x , z) , <span class="number">8 </span>=&gt; spline_helper_34 (noises , cache , x , z) , <span class="number">9 </span>=&gt; spline_helper_36 (noises , cache , x , z) , <span class="number">10 </span>=&gt; spline_helper_37 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_39 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, <span class="number">0.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.5760369 </span>, <span class="number">0.5760369</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.34792626 </span>, <span class="number">1 </span>=&gt; <span class="number">0.9239631 </span>, <span class="number">2 </span>=&gt; <span class="number">1.5 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_40 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, <span class="number">0.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.4608295 </span>, <span class="number">0.4608295</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.2 </span>, <span class="number">1 </span>=&gt; <span class="number">0.5391705 </span>, <span class="number">2 </span>=&gt; <span class="number">1.0 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_41 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, <span class="number">0.0 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.4608295 </span>, <span class="number">0.4608295</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.2 </span>, <span class="number">1 </span>=&gt; <span class="number">0.5391705 </span>, <span class="number">2 </span>=&gt; <span class="number">1.0 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_42 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.070000015</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.2 </span>, <span class="number">1 </span>=&gt; <span class="number">0.5 </span>, <span class="number">2 </span>=&gt; <span class="number">0.5 </span>, <span class="number">3 </span>=&gt; <span class="number">0.5 </span>, <span class="number">4 </span>=&gt; <span class="number">0.6 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_43 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.099999994 </span>, <span class="number">0.099999994 </span>, <span class="number">0.94 </span>, <span class="number">0.070000015</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.05 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.03 </span>, <span class="number">3 </span>=&gt; <span class="number">0.5 </span>, <span class="number">4 </span>=&gt; <span class="number">0.6 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_44 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.05 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_45 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.05 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_47 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.05 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_46 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.05 </span>, <span class="number">1 </span>=&gt; spline_helper_47 (noises , cache , x , z) , <span class="number">2 </span>=&gt; <span class="number">0.17 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_49 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.05 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_48 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.05 </span>, <span class="number">1 </span>=&gt; spline_helper_49 (noises , cache , x , z) , <span class="number">2 </span>=&gt; <span class="number">0.17 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_50 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.5 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.05 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_51 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">5</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.4 </span>, <span class="number">0.0 </span>, <span class="number">0.4 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">5</span>] = [<span class="number">0.015 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.04 </span>, <span class="number">0.049</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; - <span class="number">0.02 </span>, <span class="number">1 </span>=&gt; <span class="number">0.01 </span>, <span class="number">2 </span>=&gt; <span class="number">0.01 </span>, <span class="number">3 </span>=&gt; <span class="number">0.03 </span>, <span class="number">4 </span>=&gt; <span class="number">0.1 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_38 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">11</span>] = [- <span class="number">0.85 </span>, - <span class="number">0.7 </span>, - <span class="number">0.4 </span>, - <span class="number">0.35 </span>, - <span class="number">0.1 </span>, <span class="number">0.2 </span>, <span class="number">0.4 </span>, <span class="number">0.45 </span>, <span class="number">0.55 </span>, <span class="number">0.58 </span>, <span class="number">0.7</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">11</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_39 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_40 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_41 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_42 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_43 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_44 (noises , cache , x , z) , <span class="number">6 </span>=&gt; spline_helper_45 (noises , cache , x , z) , <span class="number">7 </span>=&gt; spline_helper_46 (noises , cache , x , z) , <span class="number">8 </span>=&gt; spline_helper_48 (noises , cache , x , z) , <span class="number">9 </span>=&gt; spline_helper_50 (noises , cache , x , z) , <span class="number">10 </span>=&gt; spline_helper_51 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_53 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">6.25 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_54 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.05 </span>, <span class="number">0.05</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">2.67 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_55 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">6.25 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_56 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">6.25 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_57 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.05 </span>, <span class="number">0.05</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">2.67 </span>, <span class="number">1 </span>=&gt; <span class="number">6.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_58 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">6.25 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_60 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.1</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.25 </span>, <span class="number">1 </span>=&gt; <span class="number">0.625 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_59 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.9 </span>, - <span class="number">0.69</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.25 </span>, <span class="number">1 </span>=&gt; spline_helper_60 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_62 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.1</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.25 </span>, <span class="number">1 </span>=&gt; <span class="number">0.625 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_61 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.9 </span>, - <span class="number">0.69</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.25 </span>, <span class="number">1 </span>=&gt; spline_helper_62 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_52 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">10</span>] = [- <span class="number">0.6 </span>, - <span class="number">0.5 </span>, - <span class="number">0.35 </span>, - <span class="number">0.25 </span>, - <span class="number">0.1 </span>, <span class="number">0.03 </span>, <span class="number">0.35 </span>, <span class="number">0.45 </span>, <span class="number">0.55 </span>, <span class="number">0.62</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">10</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_53 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_54 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_55 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_56 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_57 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_58 (noises , cache , x , z) , <span class="number">6 </span>=&gt; <span class="number">6.25 </span>, <span class="number">7 </span>=&gt; spline_helper_59 (noises , cache , x , z) , <span class="number">8 </span>=&gt; spline_helper_61 (noises , cache , x , z) , <span class="number">9 </span>=&gt; <span class="number">6.25 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_64 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">5.47 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_65 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.05 </span>, <span class="number">0.05</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">2.67 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_66 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">5.47 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_67 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">5.47 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_68 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.05 </span>, <span class="number">0.05</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">2.67 </span>, <span class="number">1 </span>=&gt; <span class="number">6.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_69 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">5.47 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_71 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.1</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">5.47 </span>, <span class="number">1 </span>=&gt; <span class="number">0.625 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_70 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.9 </span>, - <span class="number">0.69</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">5.47 </span>, <span class="number">1 </span>=&gt; spline_helper_71 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_73 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.1</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">5.47 </span>, <span class="number">1 </span>=&gt; <span class="number">0.625 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_72 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.9 </span>, - <span class="number">0.69</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">5.47 </span>, <span class="number">1 </span>=&gt; spline_helper_73 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_63 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">10</span>] = [- <span class="number">0.6 </span>, - <span class="number">0.5 </span>, - <span class="number">0.35 </span>, - <span class="number">0.25 </span>, - <span class="number">0.1 </span>, <span class="number">0.03 </span>, <span class="number">0.35 </span>, <span class="number">0.45 </span>, <span class="number">0.55 </span>, <span class="number">0.62</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">10</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_64 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_65 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_66 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_67 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_68 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_69 (noises , cache , x , z) , <span class="number">6 </span>=&gt; <span class="number">5.47 </span>, <span class="number">7 </span>=&gt; spline_helper_70 (noises , cache , x , z) , <span class="number">8 </span>=&gt; spline_helper_72 (noises , cache , x , z) , <span class="number">9 </span>=&gt; <span class="number">5.47 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_75 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">5.08 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_76 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.05 </span>, <span class="number">0.05</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">2.67 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_77 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">5.08 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_78 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">5.08 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_79 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.05 </span>, <span class="number">0.05</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">2.67 </span>, <span class="number">1 </span>=&gt; <span class="number">6.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_80 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">5.08 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_82 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.1</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">5.08 </span>, <span class="number">1 </span>=&gt; <span class="number">0.625 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_81 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.9 </span>, - <span class="number">0.69</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">5.08 </span>, <span class="number">1 </span>=&gt; spline_helper_82 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_84 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.1</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">5.08 </span>, <span class="number">1 </span>=&gt; <span class="number">0.625 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_83 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.9 </span>, - <span class="number">0.69</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">5.08 </span>, <span class="number">1 </span>=&gt; spline_helper_84 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_74 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">10</span>] = [- <span class="number">0.6 </span>, - <span class="number">0.5 </span>, - <span class="number">0.35 </span>, - <span class="number">0.25 </span>, - <span class="number">0.1 </span>, <span class="number">0.03 </span>, <span class="number">0.35 </span>, <span class="number">0.45 </span>, <span class="number">0.55 </span>, <span class="number">0.62</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">10</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_75 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_76 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_77 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_78 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_79 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_80 (noises , cache , x , z) , <span class="number">6 </span>=&gt; <span class="number">5.08 </span>, <span class="number">7 </span>=&gt; spline_helper_81 (noises , cache , x , z) , <span class="number">8 </span>=&gt; spline_helper_83 (noises , cache , x , z) , <span class="number">9 </span>=&gt; <span class="number">5.08 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_86 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_87 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.05 </span>, <span class="number">0.05</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">2.67 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_88 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_89 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_90 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.05 </span>, <span class="number">0.05</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">2.67 </span>, <span class="number">1 </span>=&gt; <span class="number">6.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_91 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_93 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_92 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [<span class="number">0.45 </span>, <span class="number">0.7</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_93 (noises , cache , x , z) , <span class="number">1 </span>=&gt; <span class="number">1.56 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_95 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_94 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [<span class="number">0.45 </span>, <span class="number">0.7</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_95 (noises , cache , x , z) , <span class="number">1 </span>=&gt; <span class="number">1.56 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_97 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_96 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.7 </span>, - <span class="number">0.15</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_97 (noises , cache , x , z) , <span class="number">1 </span>=&gt; <span class="number">1.37 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_99 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.2 </span>, <span class="number">0.2</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">6.3 </span>, <span class="number">1 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_98 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.7 </span>, - <span class="number">0.15</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_99 (noises , cache , x , z) , <span class="number">1 </span>=&gt; <span class="number">1.37 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_85 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">11</span>] = [- <span class="number">0.6 </span>, - <span class="number">0.5 </span>, - <span class="number">0.35 </span>, - <span class="number">0.25 </span>, - <span class="number">0.1 </span>, <span class="number">0.03 </span>, <span class="number">0.05 </span>, <span class="number">0.4 </span>, <span class="number">0.45 </span>, <span class="number">0.55 </span>, <span class="number">0.58</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">11</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_86 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_87 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_88 (noises , cache , x , z) , <span class="number">3 </span>=&gt; spline_helper_89 (noises , cache , x , z) , <span class="number">4 </span>=&gt; spline_helper_90 (noises , cache , x , z) , <span class="number">5 </span>=&gt; spline_helper_91 (noises , cache , x , z) , <span class="number">6 </span>=&gt; spline_helper_92 (noises , cache , x , z) , <span class="number">7 </span>=&gt; spline_helper_94 (noises , cache , x , z) , <span class="number">8 </span>=&gt; spline_helper_96 (noises , cache , x , z) , <span class="number">9 </span>=&gt; spline_helper_98 (noises , cache , x , z) , <span class="number">10 </span>=&gt; <span class="number">4.69 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_102 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.01 </span>, <span class="number">0.01</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.63 </span>, <span class="number">1 </span>=&gt; <span class="number">0.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_101 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [<span class="number">0.19999999 </span>, <span class="number">0.44999996 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.0 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; spline_helper_102 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_104 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.01 </span>, <span class="number">0.01</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.315 </span>, <span class="number">1 </span>=&gt; <span class="number">0.15 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_103 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [<span class="number">0.19999999 </span>, <span class="number">0.44999996 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.0 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; spline_helper_104 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_106 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.01 </span>, <span class="number">0.01</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.315 </span>, <span class="number">1 </span>=&gt; <span class="number">0.15 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_105 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [<span class="number">0.19999999 </span>, <span class="number">0.44999996 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.0 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; spline_helper_106 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_100 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">4</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.78 </span>, - <span class="number">0.5775 </span>, - <span class="number">0.375</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">4</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_101 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_103 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_105 (noises , cache , x , z) , <span class="number">3 </span>=&gt; <span class="number">0.0 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_109 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.01 </span>, <span class="number">0.01</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.63 </span>, <span class="number">1 </span>=&gt; <span class="number">0.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_110 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.01 </span>, <span class="number">0.01</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.63 </span>, <span class="number">1 </span>=&gt; <span class="number">0.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_108 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [<span class="number">0.19999999 </span>, <span class="number">0.44999996 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.0 </span>, <span class="number">1 </span>=&gt; spline_helper_109 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_110 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_112 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.01 </span>, <span class="number">0.01</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.63 </span>, <span class="number">1 </span>=&gt; <span class="number">0.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_111 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [<span class="number">0.19999999 </span>, <span class="number">0.44999996 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.0 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; spline_helper_112 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_114 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">2</span>] = [- <span class="number">0.01 </span>, <span class="number">0.01</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">2</span>] = [<span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.63 </span>, <span class="number">1 </span>=&gt; <span class="number">0.3 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_113 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">3</span>] = [<span class="number">0.19999999 </span>, <span class="number">0.44999996 </span>, <span class="number">1.0</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">3</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__ridges_folded) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; <span class="number">0.0 </span>, <span class="number">1 </span>=&gt; <span class="number">0.0 </span>, <span class="number">2 </span>=&gt; spline_helper_114 (noises , cache , x , z) , <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [inline] <span class="kw">fn </span>spline_helper_107 (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f32 { ({ <span class="kw">const </span>LOCATIONS : [f32 ; <span class="number">4</span>] = [- <span class="number">1.0 </span>, - <span class="number">0.78 </span>, - <span class="number">0.5775 </span>, - <span class="number">0.375</span>] ; <span class="kw">const </span>DERIVATIVES : [f32 ; <span class="number">4</span>] = [<span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0 </span>, <span class="number">0.0</span>] ; <span class="kw">let </span>coord = (cache . df_overworld__erosion) <span class="kw">as </span>f32 ; f64 :: from (spline_eval :: evaluate_spline (&amp; LOCATIONS , &amp; DERIVATIVES , coord , | __i | { <span class="kw">match </span>__i { <span class="number">0 </span>=&gt; spline_helper_108 (noises , cache , x , z) , <span class="number">1 </span>=&gt; spline_helper_111 (noises , cache , x , z) , <span class="number">2 </span>=&gt; spline_helper_113 (noises , cache , x , z) , <span class="number">3 </span>=&gt; <span class="number">0.0 </span>, <span class="kw">_ </span>=&gt; <span class="macro">unreachable !</span> () } })) }) <span class="kw">as </span>f32 } # [doc = <span class="string">"Noise router entry: `barrier`"</span>] # [inline] <span class="kw">pub fn </span>router_barrier (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; noises . n_aquifer_barrier . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">0.5 </span>, f64 :: from (z) * <span class="number">1.0</span>) } # [inline] <span class="kw">fn </span>compute_router_continentalness (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { cache . df_overworld__continents } # [doc = <span class="string">"Noise router entry: `continentalness`"</span>] # [inline] <span class="kw">pub fn </span>router_continentalness (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_continentalness } # [doc = <span class="string">"Noise router entry: `depth`"</span>] # [inline] <span class="kw">pub fn </span>router_depth (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; compute_overworld__depth (noises , cache , x , y , z) } # [inline] <span class="kw">fn </span>compute_router_erosion (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { cache . df_overworld__erosion } # [doc = <span class="string">"Noise router entry: `erosion`"</span>] # [inline] <span class="kw">pub fn </span>router_erosion (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_erosion } # [doc = <span class="string">"Noise router entry: `final_density`"</span>] # [inline] <span class="kw">pub fn </span>router_final_density (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; f64 :: min ({ <span class="kw">let </span>c = clamp (((<span class="number">0.64</span>) * (((<span class="number">0.1171875</span>) + (((map_clamped (f64 :: from (y) , - <span class="number">64.0 </span>, - <span class="number">40.0 </span>, <span class="number">0.0 </span>, <span class="number">1.0</span>)) * (((- <span class="number">0.1171875</span>) + (((- <span class="number">0.078125</span>) + (((map_clamped (f64 :: from (y) , <span class="number">240.0 </span>, <span class="number">256.0 </span>, <span class="number">1.0 </span>, <span class="number">0.0</span>)) * (((<span class="number">0.078125</span>) + ({ <span class="kw">let </span>v = compute_overworld__sloped_cheese (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">1000000.0 </span>&amp;&amp; v &lt; <span class="number">1.5625 </span>{ f64 :: min (compute_overworld__sloped_cheese (noises , cache , x , y , z) , ((<span class="number">5.0</span>) * (compute_overworld__caves__entrances (noises , cache , x , y , z)))) } <span class="kw">else </span>{ f64 :: max (f64 :: min (f64 :: min (((((<span class="number">4.0</span>) * ({ <span class="kw">let </span>v = noises . n_cave_layer . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">8.0 </span>, f64 :: from (z) * <span class="number">1.0</span>) ; v * v }))) + (((clamp (((<span class="number">0.27</span>) + (noises . n_cave_cheese . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">0.6666666666666666 </span>, f64 :: from (z) * <span class="number">1.0</span>))) , - <span class="number">1.0 </span>, <span class="number">1.0</span>)) + (clamp (((<span class="number">1.5</span>) + (((- <span class="number">0.64</span>) * (compute_overworld__sloped_cheese (noises , cache , x , y , z))))) , <span class="number">0.0 </span>, <span class="number">0.5</span>))))) , compute_overworld__caves__entrances (noises , cache , x , y , z)) , ((compute_overworld__caves__spaghetti_2d (noises , cache , x , y , z)) + (compute_overworld__caves__spaghetti_roughness_function (noises , cache , x , y , z)))) , { <span class="kw">let </span>v = compute_overworld__caves__pillars (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">1000000.0 </span>&amp;&amp; v &lt; <span class="number">0.03 </span>{ - <span class="number">1000000.0 </span>} <span class="kw">else </span>{ compute_overworld__caves__pillars (noises , cache , x , y , z) } }) } })))))))))))))) , - <span class="number">1.0 </span>, <span class="number">1.0</span>) ; c / <span class="number">2.0 </span>- c * c * c / <span class="number">24.0 </span>} , compute_overworld__caves__noodle (noises , cache , x , y , z)) } # [doc = <span class="string">"Noise router entry: `fluid_level_floodedness`"</span>] # [inline] <span class="kw">pub fn </span>router_fluid_level_floodedness (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; noises . n_aquifer_fluid_level_floodedness . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">0.67 </span>, f64 :: from (z) * <span class="number">1.0</span>) } # [doc = <span class="string">"Noise router entry: `fluid_level_spread`"</span>] # [inline] <span class="kw">pub fn </span>router_fluid_level_spread (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; noises . n_aquifer_fluid_level_spread . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">0.7142857142857143 </span>, f64 :: from (z) * <span class="number">1.0</span>) } # [doc = <span class="string">"Noise router entry: `lava`"</span>] # [inline] <span class="kw">pub fn </span>router_lava (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; noises . n_aquifer_lava . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>) } # [inline] <span class="kw">fn </span>compute_router_preliminary_surface_level (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `preliminary_surface_level`"</span>] # [inline] <span class="kw">pub fn </span>router_preliminary_surface_level (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_preliminary_surface_level } # [inline] <span class="kw">fn </span>compute_router_ridges (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { cache . df_overworld__ridges } # [doc = <span class="string">"Noise router entry: `ridges`"</span>] # [inline] <span class="kw">pub fn </span>router_ridges (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_ridges } # [inline] <span class="kw">fn </span>compute_router_temperature (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { { <span class="kw">let </span>dx = cache . df_shift_x ; <span class="kw">let </span>dz = cache . df_shift_z ; noises . n_temperature . get_value (f64 :: from (x) * <span class="number">0.25 </span>+ dx , <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25 </span>+ dz ,) } } # [doc = <span class="string">"Noise router entry: `temperature`"</span>] # [inline] <span class="kw">pub fn </span>router_temperature (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_temperature } # [inline] <span class="kw">fn </span>compute_router_vegetation (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , z : i32) -&gt; f64 { { <span class="kw">let </span>dx = cache . df_shift_x ; <span class="kw">let </span>dz = cache . df_shift_z ; noises . n_vegetation . get_value (f64 :: from (x) * <span class="number">0.25 </span>+ dx , <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25 </span>+ dz ,) } } # [doc = <span class="string">"Noise router entry: `vegetation`"</span>] # [inline] <span class="kw">pub fn </span>router_vegetation (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_vegetation } # [doc = <span class="string">"Noise router entry: `vein_gap`"</span>] # [inline] <span class="kw">pub fn </span>router_vein_gap (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; noises . n_ore_gap . get_value (f64 :: from (x) * <span class="number">1.0 </span>, f64 :: from (y) * <span class="number">1.0 </span>, f64 :: from (z) * <span class="number">1.0</span>) } # [doc = <span class="string">"Noise router entry: `vein_ridged`"</span>] # [inline] <span class="kw">pub fn </span>router_vein_ridged (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; ((- <span class="number">0.07999999821186066</span>) + (f64 :: max (({ <span class="kw">let </span>v = compute_y (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">60.0 </span>&amp;&amp; v &lt; <span class="number">51.0 </span>{ noises . n_ore_vein_a . get_value (f64 :: from (x) * <span class="number">4.0 </span>, f64 :: from (y) * <span class="number">4.0 </span>, f64 :: from (z) * <span class="number">4.0</span>) } <span class="kw">else </span>{ <span class="number">0.0 </span>} }) . abs () , ({ <span class="kw">let </span>v = compute_y (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">60.0 </span>&amp;&amp; v &lt; <span class="number">51.0 </span>{ noises . n_ore_vein_b . get_value (f64 :: from (x) * <span class="number">4.0 </span>, f64 :: from (y) * <span class="number">4.0 </span>, f64 :: from (z) * <span class="number">4.0</span>) } <span class="kw">else </span>{ <span class="number">0.0 </span>} }) . abs ()))) } # [doc = <span class="string">"Noise router entry: `vein_toggle`"</span>] # [inline] <span class="kw">pub fn </span>router_vein_toggle (noises : &amp; OverworldNoises , cache : &amp; OverworldColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; { <span class="kw">let </span>v = compute_y (noises , cache , x , y , z) ; <span class="kw">if </span>v &gt;= - <span class="number">60.0 </span>&amp;&amp; v &lt; <span class="number">51.0 </span>{ noises . n_ore_veininess . get_value (f64 :: from (x) * <span class="number">1.5 </span>, f64 :: from (y) * <span class="number">1.5 </span>, f64 :: from (z) * <span class="number">1.5</span>) } <span class="kw">else </span>{ <span class="number">0.0 </span>} } } # [doc = <span class="string">r" Nether density functions."</span>] <span class="kw">pub mod </span>nether { <span class="kw">use </span>steel_utils :: density :: spline_eval ; <span class="kw">use </span>steel_utils :: density :: RarityValueMapper ; <span class="kw">use </span>steel_utils :: math :: { clamp , map_clamped } ; <span class="kw">use </span>steel_utils :: noise :: NormalNoise ; <span class="kw">use </span>steel_utils :: random :: RandomSplitter ; # [doc = <span class="string">r" All noise generators needed by this dimension's density functions."</span>] # [doc = <span class="string">r""</span>] # [doc = <span class="string">r" Created at runtime from a seed via the `create` method."</span>] <span class="kw">pub struct </span>NetherNoises { <span class="kw">pub </span>n_offset : NormalNoise , <span class="kw">pub </span>n_temperature : NormalNoise , <span class="kw">pub </span>n_vegetation : NormalNoise } <span class="kw">impl </span>NetherNoises { # [doc = <span class="string">r" Create all noise generators from a seed's positional splitter and noise parameters."</span>] <span class="kw">pub fn </span>create (splitter : &amp; RandomSplitter , params : &amp; rustc_hash :: FxHashMap &lt; String , steel_utils :: density :: NoiseParameters &gt; ,) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ n_offset : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:offset"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:offset"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:offset" </span>, p . first_octave , &amp; p . amplitudes) } , n_temperature : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:temperature"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:temperature"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:temperature" </span>, p . first_octave , &amp; p . amplitudes) } , n_vegetation : { <span class="kw">let </span>p = params . get (<span class="string">"minecraft:vegetation"</span>) . expect (<span class="macro">concat !</span> (<span class="string">"missing noise params: " </span>, <span class="string">"minecraft:vegetation"</span>)) ; NormalNoise :: create (splitter , <span class="string">"minecraft:vegetation" </span>, p . first_octave , &amp; p . amplitudes) } } } } # [doc = <span class="string">r" Column-level cache for flat-cached (xz-only) density function results."</span>] # [doc = <span class="string">r""</span>] # [doc = <span class="string">r" Call [`ensure`](Self::ensure) before reading values. Values are recomputed"</span>] # [doc = <span class="string">r" only when `(x, z)` changes."</span>] <span class="kw">pub struct </span>NetherColumnCache { # [doc = <span class="string">r" Cached x block coordinate."</span>] <span class="kw">pub </span>x : i32 , # [doc = <span class="string">r" Cached z block coordinate."</span>] <span class="kw">pub </span>z : i32 , valid : bool , <span class="kw">pub </span>df_shift_x : f64 , <span class="kw">pub </span>df_shift_z : f64 , <span class="kw">pub </span>router_barrier : f64 , <span class="kw">pub </span>router_continentalness : f64 , <span class="kw">pub </span>router_depth : f64 , <span class="kw">pub </span>router_erosion : f64 , <span class="kw">pub </span>router_fluid_level_floodedness : f64 , <span class="kw">pub </span>router_fluid_level_spread : f64 , <span class="kw">pub </span>router_lava : f64 , <span class="kw">pub </span>router_preliminary_surface_level : f64 , <span class="kw">pub </span>router_ridges : f64 , <span class="kw">pub </span>router_temperature : f64 , <span class="kw">pub </span>router_vegetation : f64 , <span class="kw">pub </span>router_vein_gap : f64 , <span class="kw">pub </span>router_vein_ridged : f64 , <span class="kw">pub </span>router_vein_toggle : f64 } <span class="kw">impl </span>NetherColumnCache { # [doc = <span class="string">r" Create a new, empty column cache."</span>] # [must_use] <span class="kw">pub fn </span>new () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ x : <span class="number">0 </span>, z : <span class="number">0 </span>, valid : <span class="bool-val">false </span>, df_shift_x : <span class="number">0.0 </span>, df_shift_z : <span class="number">0.0 </span>, router_barrier : <span class="number">0.0 </span>, router_continentalness : <span class="number">0.0 </span>, router_depth : <span class="number">0.0 </span>, router_erosion : <span class="number">0.0 </span>, router_fluid_level_floodedness : <span class="number">0.0 </span>, router_fluid_level_spread : <span class="number">0.0 </span>, router_lava : <span class="number">0.0 </span>, router_preliminary_surface_level : <span class="number">0.0 </span>, router_ridges : <span class="number">0.0 </span>, router_temperature : <span class="number">0.0 </span>, router_vegetation : <span class="number">0.0 </span>, router_vein_gap : <span class="number">0.0 </span>, router_vein_ridged : <span class="number">0.0 </span>, router_vein_toggle : <span class="number">0.0 </span>} } # [doc = <span class="string">r" Ensure the cache is populated for the given `(x, z)` block coordinates."</span>] # [doc = <span class="string">r""</span>] # [doc = <span class="string">r" If the cache already holds values for this column, this is a no-op."</span>] # [doc = <span class="string">r" Computes all flat-cached density functions in topological order,"</span>] # [doc = <span class="string">r" then any Y-independent router entries."</span>] <span class="kw">pub fn </span>ensure (&amp; <span class="kw-2">mut </span><span class="self">self </span>, x : i32 , z : i32 , noises : &amp; NetherNoises) { <span class="kw">if </span><span class="self">self </span>. valid &amp;&amp; <span class="self">self </span>. x == x &amp;&amp; <span class="self">self </span>. z == z { <span class="kw">return </span>; } <span class="self">self </span>. x = x ; <span class="self">self </span>. z = z ; <span class="kw">let </span>val = compute_shift_x (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_shift_x = val ; <span class="kw">let </span>val = compute_shift_z (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. df_shift_z = val ; <span class="kw">let </span>val = compute_router_barrier (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_barrier = val ; <span class="kw">let </span>val = compute_router_continentalness (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_continentalness = val ; <span class="kw">let </span>val = compute_router_depth (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_depth = val ; <span class="kw">let </span>val = compute_router_erosion (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_erosion = val ; <span class="kw">let </span>val = compute_router_fluid_level_floodedness (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_fluid_level_floodedness = val ; <span class="kw">let </span>val = compute_router_fluid_level_spread (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_fluid_level_spread = val ; <span class="kw">let </span>val = compute_router_lava (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_lava = val ; <span class="kw">let </span>val = compute_router_preliminary_surface_level (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_preliminary_surface_level = val ; <span class="kw">let </span>val = compute_router_ridges (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_ridges = val ; <span class="kw">let </span>val = compute_router_temperature (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_temperature = val ; <span class="kw">let </span>val = compute_router_vegetation (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_vegetation = val ; <span class="kw">let </span>val = compute_router_vein_gap (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_vein_gap = val ; <span class="kw">let </span>val = compute_router_vein_ridged (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_vein_ridged = val ; <span class="kw">let </span>val = compute_router_vein_toggle (noises , &amp; * <span class="self">self </span>, x , z) ; <span class="self">self </span>. router_vein_toggle = val ; <span class="self">self </span>. valid = <span class="bool-val">true </span>; } } # [doc = <span class="string">"`minecraft:nether/base_3d_noise`"</span>] # [inline] <span class="kw">fn </span>compute_nether__base_3d_noise (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { noises . n_offset . get_value (f64 :: from (x) * <span class="number">0.003125 </span>, f64 :: from (y) * <span class="number">0.00625 </span>, f64 :: from (z) * <span class="number">0.003125</span>) * <span class="number">8.0 </span>} # [doc = <span class="string">"`minecraft:shift_x`"</span>] # [inline] <span class="kw">fn </span>compute_shift_x (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { noises . n_offset . get_value (f64 :: from (x) * <span class="number">0.25 </span>, <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25</span>) * <span class="number">4.0 </span>} # [doc = <span class="string">"`minecraft:shift_z`"</span>] # [inline] <span class="kw">fn </span>compute_shift_z (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { noises . n_offset . get_value (f64 :: from (z) * <span class="number">0.25 </span>, f64 :: from (x) * <span class="number">0.25 </span>, <span class="number">0.0</span>) * <span class="number">4.0 </span>} # [inline] <span class="kw">fn </span>compute_router_barrier (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `barrier`"</span>] # [inline] <span class="kw">pub fn </span>router_barrier (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_barrier } # [inline] <span class="kw">fn </span>compute_router_continentalness (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `continentalness`"</span>] # [inline] <span class="kw">pub fn </span>router_continentalness (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_continentalness } # [inline] <span class="kw">fn </span>compute_router_depth (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `depth`"</span>] # [inline] <span class="kw">pub fn </span>router_depth (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_depth } # [inline] <span class="kw">fn </span>compute_router_erosion (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `erosion`"</span>] # [inline] <span class="kw">pub fn </span>router_erosion (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_erosion } # [doc = <span class="string">"Noise router entry: `final_density`"</span>] # [inline] <span class="kw">pub fn </span>router_final_density (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { <span class="kw">let </span>x = cache . x ; <span class="kw">let </span>z = cache . z ; { <span class="kw">let </span>c = clamp (((<span class="number">0.64</span>) * (((<span class="number">2.5</span>) + (((map_clamped (f64 :: from (y) , - <span class="number">8.0 </span>, <span class="number">24.0 </span>, <span class="number">0.0 </span>, <span class="number">1.0</span>)) * (((- <span class="number">2.5</span>) + (((<span class="number">0.9375</span>) + (((map_clamped (f64 :: from (y) , <span class="number">104.0 </span>, <span class="number">128.0 </span>, <span class="number">1.0 </span>, <span class="number">0.0</span>)) * (((- <span class="number">0.9375</span>) + (compute_nether__base_3d_noise (noises , cache , x , y , z))))))))))))))) , - <span class="number">1.0 </span>, <span class="number">1.0</span>) ; c / <span class="number">2.0 </span>- c * c * c / <span class="number">24.0 </span>} } # [inline] <span class="kw">fn </span>compute_router_fluid_level_floodedness (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `fluid_level_floodedness`"</span>] # [inline] <span class="kw">pub fn </span>router_fluid_level_floodedness (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_fluid_level_floodedness } # [inline] <span class="kw">fn </span>compute_router_fluid_level_spread (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `fluid_level_spread`"</span>] # [inline] <span class="kw">pub fn </span>router_fluid_level_spread (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_fluid_level_spread } # [inline] <span class="kw">fn </span>compute_router_lava (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `lava`"</span>] # [inline] <span class="kw">pub fn </span>router_lava (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_lava } # [inline] <span class="kw">fn </span>compute_router_preliminary_surface_level (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `preliminary_surface_level`"</span>] # [inline] <span class="kw">pub fn </span>router_preliminary_surface_level (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_preliminary_surface_level } # [inline] <span class="kw">fn </span>compute_router_ridges (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `ridges`"</span>] # [inline] <span class="kw">pub fn </span>router_ridges (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_ridges } # [inline] <span class="kw">fn </span>compute_router_temperature (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { { <span class="kw">let </span>dx = cache . df_shift_x ; <span class="kw">let </span>dz = cache . df_shift_z ; noises . n_temperature . get_value (f64 :: from (x) * <span class="number">0.25 </span>+ dx , <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25 </span>+ dz ,) } } # [doc = <span class="string">"Noise router entry: `temperature`"</span>] # [inline] <span class="kw">pub fn </span>router_temperature (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_temperature } # [inline] <span class="kw">fn </span>compute_router_vegetation (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { { <span class="kw">let </span>dx = cache . df_shift_x ; <span class="kw">let </span>dz = cache . df_shift_z ; noises . n_vegetation . get_value (f64 :: from (x) * <span class="number">0.25 </span>+ dx , <span class="number">0.0 </span>, f64 :: from (z) * <span class="number">0.25 </span>+ dz ,) } } # [doc = <span class="string">"Noise router entry: `vegetation`"</span>] # [inline] <span class="kw">pub fn </span>router_vegetation (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_vegetation } # [inline] <span class="kw">fn </span>compute_router_vein_gap (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `vein_gap`"</span>] # [inline] <span class="kw">pub fn </span>router_vein_gap (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_vein_gap } # [inline] <span class="kw">fn </span>compute_router_vein_ridged (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `vein_ridged`"</span>] # [inline] <span class="kw">pub fn </span>router_vein_ridged (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_vein_ridged } # [inline] <span class="kw">fn </span>compute_router_vein_toggle (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , z : i32) -&gt; f64 { <span class="number">0.0 </span>} # [doc = <span class="string">"Noise router entry: `vein_toggle`"</span>] # [inline] <span class="kw">pub fn </span>router_vein_toggle (noises : &amp; NetherNoises , cache : &amp; NetherColumnCache , x : i32 , y : i32 , z : i32) -&gt; f64 { cache . router_vein_toggle } }</code></pre></div></section></main></body></html>